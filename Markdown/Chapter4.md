# 类与对象
- 第一次加载类的时候会进行类的加载，也就是跳转到 `ClassLoader.java`文件的 `loadClass` 方法，每个不同的类只需要加载一次。
- 成员变量有默认值，局部变量没有默认值，一定需要初始化。
- 引用类型（除了基础类型之外的所有类）做成员变量时不经初始化都会被赋值`null`。
- 在执行构造器方法之前类已经完成了类的内存空间分配、已经创建好了对象，所有成员变量已经完成了默认初始化，再执行构造器方法
- 初探内存分析：
    - ![img.png](img.png)
- this:
    - 
- 在Java中，每当你调用一个方法时，Java虚拟机会创建一个称为"栈帧"（stack frame）的数据结构来存储该方法的局部变量、方法参数和其他与方法执行相关的信息。每个方法调用都会在调用栈中创建一个新的栈帧。
对于实例方法而言，每个栈帧还会包含一个指向当前对象的引用，这个引用就是this关键字所引用的对象。this引用存储在栈帧中的局部变量表中。
- JAVA运行时的内存分为三个部分：栈帧（主要存储局部变量以及形参）、堆（主要存储对象、数组）、方法区（字节码信息、字符串常量池、静态域）
  - 在类加载的时候也会将静态内容加载到方法区的静态域中（也即是静态区的内容先于对象创建、并且默认初始化）
  - 静态属性可以用于共享数据的情形
  - 静态方法只能访问类的静态属性（其他成员变量可能还未初始化）、不能访问非静态方法、不能访问this
  - 静态块在类加载时就执行，并且只执行一次
- import 导包时没有包含关系（导入package时 package 中 package的类不会被导入进去）
- 有关final实例域：可以将实例域定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每一个构造器执行之后， 这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。 例如， 可以将 Employee 类中的 name 域声明为 final, 因为在对象构建之后， 这个值不会再被修改， 即没有 setName 方法。
- 类方法的重写：子类重写父类方法时，方法名、参数列表要和父类完全一致
- 重载与重写的区别：重载发生在同一个类里面，方法名相同参数列表不同的情况；重写发生在父类子类之间，方法名以及参数列表相同的情况![](Snipaste_2023-06-11_10-32-38.png)
- 类的构造器第一行都有一个省略的super(),先将父类的属性初始化完成。
- 在构造器中，super调用父类构造器和this调用子类构造器只能存在一个，两者不能共存因为super修饰构造器要放在第一行，this修饰构造器也要放在第一行:（本质上还是一个方法内不能两次使用super()）

# Object类
- toString 方法 
  - getClass().getName() + '@' + Integer.toHexString(hashCode())
- equals 方法
  - 比较引用类型时比较的是地址值
  - 可以先用instanceof判断要比较的类是否合法

# 多态
- 多态的要素:
  - 继承:Cat extends Animal ,ig extends Animal, Dog extends Animal
  - 重写:子类对父类的方法重写
  - 父类引用指向子类对象（向上转型）
- 多态的一种非常常见的应用场合:父类当方法的形参，然后传入的是具体的子类的对象然后调用同一个方法，根据传入的子类的不同展现出来的效果也不同，构成了多态。还应用到工厂设计模式，可以用父类作为方法的返回类型。
  - 父类当做方法的形参，传入具体的子类的对象
  - 父类当做方法的返回值，返回的是具体的子类的对象
  - 接口当做方法的形参，传入具体实现类的对象
  - 接口当做方法的返回值，返回的是具体实现类的对象
- 向下转型：为了获取子类中特有的内容：
  - 在[](equals方法.png) 中虽然使用`instanceo`判断了obj的类型，但编译器仍然把obj看做Object类型，想要使用其Phone类型的属性和方法就要向下转型。
- **当子类重写父类的类方法时，父类方法的字节码仍然存在于方法区中，但在方法调用时，会根据实际对象的类型来决定使用哪个方法实现。这个过程被称为动态方法调度（Dynamic Method Dispatch）。具体来说，方法区中存储了类的方法表（Method Table），该表记录了每个方法的字节码地址。当调用一个重写的类方法时，Java虚拟机会根据对象的实际类型在方法表中查找相应的方法字节码，然后执行该方法。**
- **当子类继承父类的方法时，子类并不会复制父类的方法代码到自己的内存空间中。相反，子类会存储对父类方法的引用。子类重写的方法会被存储在子类的方法区中，覆盖了父类的方法。当子类调用这个方法时，会执行子类自己的实现。**
# final 
- final 修饰方法，那么该方法不可以被子类重写
- final 修饰类，代表该类不可以被继承。
# 抽象类
- 抽象类是一种具有抽象方法的类。抽象方法是一种没有具体实现的方法，只有方法的声明，没有方法体。抽象方法用关键字abstract声明，并以分号结束。抽象类可以包含抽象方法和非抽象方法。
- 抽象类不能被实例化。这意味着无法创建抽象类的对象。只能通过继承抽象类来创建子类，并在子类中实现抽象方法。子类必须提供抽象类中所有抽象方法的具体实现，否则子类也必须声明为抽象类。但可以通过多态实现，作为非抽象子类实例对象的引用。
- 抽象类可以包含非抽象方法。除了抽象方法之外，抽象类还可以包含具有实际实现的普通方法。子类可以直接继承并使用这些非抽象方法，而不需要重新实现。
- 抽象类可以有成员变量。抽象类可以包含成员变量，这些成员变量在子类中可见。子类可以直接访问和使用这些成员变量。

# 接口 Interface
- 接口中没有构造器，在JDK 1.8之前，接口中只有常量(public static final)和抽象方法（public abstract）。
- 接口不能创建对象，但可以通过多态指向接口的实现类实例。（多态）

# 内部类
- 内部类可以访问外部类的内容